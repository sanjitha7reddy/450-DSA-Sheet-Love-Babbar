Given an array arr[]. Find the majority element in the array. If no majority element exists, return -1.

Note: A majority element in an array is an element that appears strictly more than arr.size()/2 times in the array.

Examples:

Input: arr[] = [1, 1, 2, 1, 3, 5, 1]
Output: 1
Explanation: Since, 1 is present more than 7/2 times, so it is the majority element.

Input: arr[] = [7]
Output: 7
Explanation: Since, 7 is single element and present more than 1/2 times, so it is the majority element.

Input: arr[] = [2, 13]
Output: -1
Explanation: Since, no element is present more than 2/2 times, so there is no majority element.



class Solution {
  public:
    int majorityElement(vector<int>& arr) {
        // code here
        //Booyer Moore algorithm
        //now its cus if u use a map ,it takes up space like O(n)
        
        int n=arr.size();
        if(n==0) return -1;
        int candidate =arr[0];
        int count=0;
        for(int x:arr){
            if(count==0){
                candidate=x;
                count=1;
            }
            else if(x==candidate){
                count++;
            }
            else count--;
        }
        int freq=0;
        for(int y:arr){
            if(y==candidate) freq++;
        }
        if(freq>n/2)return candidate;
        return -1;
    }
};

Time Complexity: O(n)
Auxiliary Space: O(1)
