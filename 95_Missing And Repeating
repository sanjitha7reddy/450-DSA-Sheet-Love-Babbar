Given an unsorted array arr[] of size n, containing elements from the range 1 to n, it is known that one number in this range is missing, and another number occurs twice in the array, find both the duplicate number and the missing number.

Examples:

Input: arr[] = [2, 2]
Output: [2, 1]
Explanation: Repeating number is 2 and the missing number is 1.

Input: arr[] = [1, 3, 3] 
Output: [3, 2]
Explanation: Repeating number is 3 and the missing number is 2.


class Solution {
  public:
    vector<int> findTwoElement(vector<int>& arr) {
        // code here
       long n = arr.size();

        // Step 1: Compute expected sums (formula-based)
        long asum = (n * (n + 1)) / 2;               // 1 + 2 + ... + n
        long asum2 = (n * (n + 1) * (2 * n + 1)) / 6; // 1^2 + 2^2 + ... + n^2

        // Step 2: Compute observed sums (from array)
        long obsum = 0, obsum2 = 0;
        for (long val : arr) {
            obsum += val;
            obsum2 += (val * val);
        }

        // Step 3: Differences
        long val1 = asum - obsum;   // missing - repeating
        long val2 = asum2 - obsum2; // missing^2 - repeating^2

        // Step 4: Get missing + repeating using identity
        long sum_mr = val2 / val1;  // (m + r)

        // Step 5: Solve equations
        long missing = (val1 + sum_mr) / 2;
        long repeating = missing - val1;

        // Step 6: Return as vector
        return { (int)repeating, (int)missing };
        

    }
};
/*
 int n=arr.size();
        vector<int>res;
        map<int,int>mp;
        for(int i=0;i<n;i++){
            mp[arr[i]]++;
        }
        int duplicate=-1,miss=-1;
        for(int i=1;i<=n;i++)
        {
            if(mp[i]==2)
            {
                duplicate=i;
            }
            if(mp[i]==0)
            {
                miss=i;
            }
        }
         res.push_back(duplicate);
         res.push_back(miss);
         return res;
         */


Time Complexity: O(n)
Auxiliary Space: O(1)
